/*!
 * Codecolor.js v1.0.0
 * https://codecolorjs.pw/
 *
 * (c) 2018-2019 Daniil Ryazanov <opensource@tagproject.ru>
 * Released under the MIT License.
 */

(function(a,b){"object"==typeof exports&&"undefined"!=typeof module?module.exports=b():"function"==typeof define&&define.amd?define(b):(a=a||self,a.codecolor=b())})(this,function(){"use strict";const a="cc-",b="source";class c{constructor(a,b){this.name=void 0,this.expressions=void 0,this.keywords=void 0,this.masks=void 0,this.activeKeywords=void 0,this.activeExpressions=void 0,this.name=a,this.expressions=b.expressions.values,this.activeExpressions=b.expressions.names,this.keywords="object"==typeof b.keywords?b.keywords.values:[],this.activeKeywords="object"==typeof b.keywords?b.keywords.names:[],this.masks=b.masks}eachExp(a){this.expressions.forEach((b,c)=>{b.forEach((b,d)=>{a(this.activeExpressions[c],b,d)})})}getKeywordName(a){const b=a[0];let c,d=0;for(;(c=this.keywords[d])&&!(c[b]&&~c[b].indexOf(a));)d++;return this.activeKeywords[d]}getMask(a,b){let c;return"undefined"!=typeof this.masks&&Array.isArray(this.masks[a])&&!!this.masks[a][b]&&(c=this.masks[a][b]),c}}class d{constructor(a,b,c,d){this.name=void 0,this.value=void 0,this.start=void 0,this.end=void 0,this.ruleIndex=void 0,this.name=a,this.value=b,this.start=c,this.end=c+b.length,this.ruleIndex=d}isIncludedIn(a){return this.start>=a.start&&this.end<=a.end}isCross(a){return this.start>=a.start&&this.start<=a.end&&this.end>=a.end}isSource(){return this.name===b}}class e{static parse(a,b,c){let d=a;if("undefined"!=typeof c[b]){const a=new e(d,b,c);a.analize(),d=a.render()}return d}constructor(a,b,c){this.code=void 0,this.languages=void 0,this.language=void 0,this.tokens=void 0,this.code=a,this.languages=c,this.language=c[b],this.tokens=[]}analize(){let a,b,c,e,f=NaN;const{tokens:g}=this,h=a=>~~(a/2),i=(a,b)=>{if(b<=g.length&&a<b){if(e=g[b-1],e.end<=c.start)return i(b,b+h(g.length-b+1));if(e.start>=c.end)return i(a,a+h(b-a));if(c.isIncludedIn(e))return-Infinity;if(e.isIncludedIn(c))return 1===b?1/0:-(b-1);if(e.isCross(c))return 1/0}return b};this.language.eachExp((e,j,k)=>{var l=Math.abs,m=Number.isFinite,n=Math.max;for(b=new RegExp(j,"gm");a=b.exec(this.code);)c=new d(e,a[0],a.index,k),0<=(f=i(0,n(h(g.length),1)))?m(f)?g.splice(f,0,c):g[0]=c:m(f)&&(g[l(f)]=c)})}wrap(c){const d=(b,c)=>`<span class="${a}${b}">${c}</span>`,f=c.isSource()?this.language.getKeywordName(c.value):c.name;let g;if("undefined"==typeof f)g=c.value;else{const h=this.language.getMask(f,c.ruleIndex);if("undefined"==typeof h)g=d(f,c.value);else if("string"==typeof h)g=d(`${f} ${a}${h}`,c.value);else{const[a,i,j]=h,k=new RegExp(a,"gm"),l=[];let m,n=0;for(;m=k.exec(c.value);)l.push(c.value.substring(n,m.index),d(j||b,e.parse(m[0],i,this.languages))),n=k.lastIndex;l.push(c.value.substring(n,c.value.length)),g=d(f,l.join(""))}}return g}render(){const a=[];let b=0;return this.tokens.forEach(c=>{b<c.start&&a.push(this.code.substring(b,c.start)),a.push(this.wrap(c)),b=c.end}),a.push(this.code.substring(b)),a.join("")}}var f=new class{constructor(){this.version="1.0.0",this.languages={},this.activeSchema=void 0}highlight(b,c){return[`<pre><code class="${a}container">`,e.parse(b,c||this.activeSchema,this.languages),"</code></pre>"].join("")}addSchema(a){return this.languages[a.name]=new c(a.name,a),this.activeSchema=a.name,a.name}};return f});
