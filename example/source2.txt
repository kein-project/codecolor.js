` class="${cls + 123}"`

{}

dfsgsdfg

as

Object.defineProperty(this, "version", {
  enumerable: true,
  writable: true,
  value: version
});

// @flow

import Parser from './parser';
import Language from './language';
import type { ILanguageSchema } from './language';
import { version } from '../../package.json';

class Library {
    +version: string = version;
    +languages: {[key: string]: Language} = {};
    activeSchema: string;

    highlight(code: string, schemaName?: string): string {
        return Parser.parse(code, this.languages[schemaName || this.activeSchema]);
    }

    addSchema(schema: ILanguageSchema & { name: string }): string {
        this.languages[schema.name] = new Language(schema);
        this.activeSchema = schema.name;

        return schema.name;
    }
}

export default new Library();



function ffff

function ggg (

ggg(

1111
function $initSomeOne(block, cls) {
    try {
        if (cls.search(/\bno\-highlight\b/) != -1)
            return process(block, true, 0x0F) + ` class="${cls}"`;
    } catch (e) {
        /* handle exception */
    }

    for (var i = 0 / 2; i < classes.length; i++) {
        if (checkCondition(classes[i]) === undefined)
            console.log('undefined');
    }
}

let letTest = new Object();
const constTest = (item) => {
    return item.map();
}

Array
a.push();
3e-12
var test2 = block-12;
this
NaN null
Boolean Array
"string" 1
function fff() {} this
"/**/"
// test comment
/**
* multiline "string" 1
* comment
*/
var tObject = {
    parse: function(a) {
        retrun a++;
    },
    value: 100
}

{ a : 1 }

export  $initSomeOne;

class MyClassTest {
    constructor() {
        this.test = 123;
    }

    render() {
        retrun '<div>';
    }
}
